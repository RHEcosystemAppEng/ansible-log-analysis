# Default values for backend.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 2

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: quay.io/rh-ai-quickstart/alm-backend
  # This sets the pull policy for images.
  pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
# imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
# serviceAccount:
#   # Specifies whether a service account should be created
#   create: true
#   # Automatically mount a ServiceAccount's API credentials?
#   automount: true
#   # Annotations to add to the service account
#   annotations: {}
#   # The name of the service account to use.
#   # If not set and create is true, a name is generated using the fullname template
#   name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 8000
  targetPort: 8000

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/use-regex: "true"
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: ansible-log-monitor-backend.local
      paths:
        - path: /api(/|$)(.*)
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: ansible-log-monitor-backend-tls
  #    hosts:
  #      - ansible-log-monitor-backend.local

resources:
  limits:
    cpu: 1000m
    memory: 5Gi
  requests:
    cpu: 100m
    memory: 1Gi

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
readinessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

backend:
  env:

# Environment variables for the FastAPI application
env:
  - name: DATABASE_URL
    valueFrom:
      secretKeyRef:
        name: pgvector
        key: uri
  - name: MINIO_ENDPOINT
    valueFrom:
      secretKeyRef:
        name: minio
        key: host
  - name: MINIO_ACCESS_KEY
    valueFrom:
      secretKeyRef:
        name: minio
        key: user
  - name: MINIO_SECRET_KEY
    valueFrom:
      secretKeyRef:
        name: minio
        key: password
  - name: MINIO_PORT
    valueFrom:
      secretKeyRef:
        name: minio
        key: port

  - name: MINIO_BUCKET_NAME
    value: "clustering-model"

  - name: CLUSTERING_HOST
    value: "alm-clustering"
  - name: CLUSTERING_PORT
    value: "8001"
  - name: COLLECTOR_ENDPOINT
    value: "http://phoenix:6006/v1/traces"
  # - name: PROD_CORS_ORIGIN # TODO check me
  #   value: "http://localhost:3000"


# ConfigMap configuration
config:
  # Application configuration
  logLevel: "INFO"
  debug: false

  # LangSmith configuration
  langsmith:
    tracing: false
    apiKey: "your-langsmith-api-key"
    project: "ansible-log-monitor"
  
  # Clustering configuration
  clustering:
    sentenceTransformerModelName: "Qwen/Qwen3-Embedding-0.6B"
    algorithm: "meanshift"
    tmpClusterModelPath: "clustering_model.joblib"

# RBAC configuration
rbac:
  # Specifies whether RBAC resources should be created
  create: false
  # Rules to be added to the Role
  rules: []
  # Example rules:
  # - apiGroups: [""]
  #   resources: ["pods", "services"]
  #   verbs: ["get", "list", "watch"]

# Secrets for sensitive configuration
# secrets: {}
  # DATABASE_PASSWORD: "supersecretpassword"
  # API_KEY: "your-api-key"
  # JWT_SECRET: "jwt-signing-secret"

# PostgreSQL dependency configuration
postgresql:
  # Whether to wait for PostgreSQL to be ready before starting the main container
  waitForReady: true
